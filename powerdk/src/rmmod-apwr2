#!/bin/bash
# Description: script to unload the power driver on Android.
# Version: 1.0

# ***********************************************************************************************

 # This file is provided under a dual BSD/GPLv2 license.  When using or
 # redistributing this file, you may do so under either license.

  # GPL LICENSE SUMMARY

  # Copyright(c) 2011 Intel Corporation. All rights reserved.

  # This program is free software; you can redistribute it and/or modify
  # it under the terms of version 2 of the GNU General Public License as
  # published by the Free Software Foundation.

  # This program is distributed in the hope that it will be useful, but
  # WITHOUT ANY WARRANTY; without even the implied warranty of
  # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  # General Public License for more details.

  # You should have received a copy of the GNU General Public License
  # along with this program; if not, write to the Free Software
  # Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
  # The full GNU General Public License is included in this distribution
  # in the file called LICENSE.GPL.

  # Contact Information:
  # Gautam Upadhyaya <gautam.upadhyaya@intel.com>
  # 1906 Fox Drive, Champaign, IL - 61820, USA

  # BSD LICENSE

  # Copyright(c) 2011 Intel Corporation. All rights reserved.
  # All rights reserved.

  # Redistribution and use in source and binary forms, with or without
  # modification, are permitted provided that the following conditions
  # are met:

  #   * Redistributions of source code must retain the above copyright
  #     notice, this list of conditions and the following disclaimer.
  #   * Redistributions in binary form must reproduce the above copyright
  #     notice, this list of conditions and the following disclaimer in
  #     the documentation and/or other materials provided with the
  #     distribution.
  #   * Neither the name of Intel Corporation nor the names of its
  #     contributors may be used to endorse or promote products derived
  #     from this software without specific prior written permission.

  # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  # A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  #
# ***********************************************************************************************

# ------------------------------ CONSTANTS -----------------------------------

# base driver name and version
DRIVER_BASE=apwr
DRIVER_MAJOR=2
DRIVER_MINOR=2
# basic name of driver
DRIVER_NAME=${DRIVER_BASE}${DRIVER_MAJOR}_${DRIVER_MINOR}
# Character device file name -- APWR uses a driver-agnostic file name
DEV_FILE_NAME=apwr_driver_char_dev

# ------------------------------- OUTPUT -------------------------------------

print_msg()
{
  MSG="$*"
  echo "$MSG"
}

print_nnl()
{
  MSG="$*"
  echo -n "$MSG"
}

print_err()
{
  MSG="$*"
  if [ -w /dev/stderr ] ; then
    echo "$MSG" >> /dev/stderr
  else
    echo "$MSG"
  fi
}

# GU: For Android Honeycomb, make sure we pull in "busybox"
export PATH=/system/xbin/busybox:/sbin:$PATH

# set the path to include "standard" locations so commands below can be found
#PATH="/sbin:/usr/sbin:/bin:/usr/bin/:/usr/local/sbin:/usr/local/bin:/usr/local/gnu/bin:"${PATH}":."
#export PATH

# ------------------------------ COMMANDS ------------------------------------

CUT="cut"
GREP="grep"
INSMOD="insmod"
LSMOD="lsmod"
PGREP="pgrep"
#PKILL="pkill"
RM="rm"
RMMOD="rmmod"
RMMOD_ADRD="/system/bin/rmmod"
SED="sed"
SU="su"
TR="tr"
UNAME="uname"

#COMMANDS_TO_CHECK="${CUT} ${GREP} ${INSMOD} ${LSMOD} ${PGREP} ${PKILL} ${RM} ${RMMOD} ${SED} ${SU} ${TR} ${UNAME}"
#COMMANDS_TO_CHECK="${CUT} ${GREP} ${INSMOD} ${LSMOD} ${PGREP} ${PKILL} ${RM} ${SED} ${SU} ${TR} ${UNAME}"
COMMANDS_TO_CHECK="${CUT} ${GREP} ${INSMOD} ${LSMOD} ${RM} ${SED} ${SU} ${TR} ${UNAME}"
RMMOD_TO_CHECK="${RMMOD_ADRD} ${RMMOD}"

# if any of the COMMANDS_TO_CHECK are not executable, then exit script
OK="true"
for c in ${COMMANDS_TO_CHECK} ; do
  CMD=`type -P $c 2>&1` ;
  if [ -z "${CMD}" ] ; then
    OK="false"
    print_err "ERROR: unable to find command \"$c\" !"
  fi
done
if [ ${OK} != "true" ] ; then
  print_err "Please add the above commands to your PATH and re-run the script ... exiting."
  exit 255
fi

# special case for "rmmod" -- we check for EITHER 'rmmod' path
OK="false"
for c in ${RMMOD_TO_CHECK} ; do
  CMD=`type -P $c 2>&1` ;
  if [ -z "${CMD}" ] ; then
    OK="false";
  else
    OK="true";
    ACT_RMMOD=${c}
    break
  fi
done

if [ ${OK} != "true" ] ; then
  print_err "Fatal error: Could NOT locate the \"rmmod\" command -- please add it to your path before continuing! EXITING";
  exit 255
fi

# ------------------------------ VARIABLES -----------------------------------

SCRIPT=$0
PLATFORM=`${UNAME} -m`
KERNEL_VERSION=`${UNAME} -r`

# set the directory of the rmmod-apwr3 script
SCRIPT_DIR=`dirname $0`

# ------------------------------ FUNCTIONS -----------------------------------

# function to show usage and exit
print_usage_and_exit()
{
  err=${1:-0}
  print_msg ""
  print_msg "Usage: $0 "
  print_msg ""
  exit $err
}

# check for certain options
# GU: NOT supported for APWR

# --------------------------------- MAIN -------------------------------------

# check for a loaded driver (should be only one)
DRIVER_LOADED=`${LSMOD} | ${GREP} ${DRIVER_NAME} | ${CUT} -d ' ' -f 1`

# if no driver is loaded then exit
if [ -z "${DRIVER_LOADED}" ] ; then
  print_msg "Warning:  no ${DRIVER_NAME} driver was found loaded in the kernel."
  exit 0
fi

# check if USER is root
if [ "${USER}x" != "rootx" ] ; then
  if [ ! -w /dev ] ; then
    print_msg "NOTE:  super-user or \"root\" privileges are required in order to continue."
    print_nnl "Please enter \"root\" "
    OPTIONS=""
    exec ${SU} -c "/bin/bash ${SCRIPT} ${OPTIONS}"
    print_msg ""
    exit 0
  fi
fi

# shutdown any currently running APWR processes
# GU: NOT supported for APWR


# if APWR driver is loaded, then attempt to remove it
if [ -n "${DRIVER_LOADED}" ] ; then
  print_nnl "Removing ${DRIVER_NAME} driver from the kernel ... "
  sleep 1
  ${ACT_RMMOD} ${DRIVER_NAME}
  RMMOD_RESULT=$?
  if [ ${RMMOD_RESULT} -ne 0 ] ; then
    print_err ""
    print_err "Error:  unable to remove the driver from the kernel ... exiting."
    print_err ""
    exit 246
  fi
  print_msg "done."
fi

# remove APWR device file (created by the 'insmod' script)
if [ -e /dev/${DEV_FILE_NAME} ] ; then
  print_nnl "Deleting /dev/${DEV_FILE_NAME} devices ... "
  sleep 1
  ${RM} /dev/${DEV_FILE_NAME}
  print_msg "done."
fi

# show which APWR driver was loaded
if [ -n "${DRIVER_LOADED}" ] ; then
  print_msg "The ${DRIVER_NAME} driver has been successfully unloaded."
fi

# if requested, attempt to unload PAX driver
# GU: NOT supported for APWR

exit 0
