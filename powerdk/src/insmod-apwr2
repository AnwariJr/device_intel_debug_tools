#!/bin/bash
# Description: script to load the power driver on Android.
# Version: 1.0

# ***********************************************************************************************

 # This file is provided under a dual BSD/GPLv2 license.  When using or
 # redistributing this file, you may do so under either license.

  # GPL LICENSE SUMMARY

  # Copyright(c) 2011 Intel Corporation. All rights reserved.

  # This program is free software; you can redistribute it and/or modify
  # it under the terms of version 2 of the GNU General Public License as
  # published by the Free Software Foundation.

  # This program is distributed in the hope that it will be useful, but
  # WITHOUT ANY WARRANTY; without even the implied warranty of
  # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  # General Public License for more details.

  # You should have received a copy of the GNU General Public License
  # along with this program; if not, write to the Free Software
  # Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
  # The full GNU General Public License is included in this distribution
  # in the file called LICENSE.GPL.

  # Contact Information:
  # Gautam Upadhyaya <gautam.upadhyaya@intel.com>
  # 1906 Fox Drive, Champaign, IL - 61820, USA

  # BSD LICENSE

  # Copyright(c) 2011 Intel Corporation. All rights reserved.
  # All rights reserved.

  # Redistribution and use in source and binary forms, with or without
  # modification, are permitted provided that the following conditions
  # are met:

  #   * Redistributions of source code must retain the above copyright
  #     notice, this list of conditions and the following disclaimer.
  #   * Redistributions in binary form must reproduce the above copyright
  #     notice, this list of conditions and the following disclaimer in
  #     the documentation and/or other materials provided with the
  #     distribution.
  #   * Neither the name of Intel Corporation nor the names of its
  #     contributors may be used to endorse or promote products derived
  #     from this software without specific prior written permission.

  # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  # A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  #
# ***********************************************************************************************

# ------------------------------ CONSTANTS -----------------------------------

# base driver name and version
DRIVER_BASE=apwr
DRIVER_MAJOR=2
DRIVER_MINOR=2
# basic name of driver
DRIVER_NAME=${DRIVER_BASE}${DRIVER_MAJOR}_${DRIVER_MINOR}
# Character device file name -- APWR uses a driver-agnostic file name
DEV_FILE_NAME=apwr_driver_char_dev
# name to use with insmod/rmmod scripts
DRIVER_NAME_SCRIPT=${DRIVER_BASE}${DRIVER_MAJOR}
# name of rmmod script
RMMOD_SCRIPT=rmmod-${DRIVER_NAME_SCRIPT}
# default driver device group
DEFAULT_GROUP=${GROUP:-root}
# default driver device permissions
DEFAULT_PERMS=660
# permissions for driver device directory
DIR_PERMS=775

# ------------------------------- OUTPUT -------------------------------------

print_msg()
{
  MSG="$*"
  echo "$MSG"
}

print_nnl()
{
  MSG="$*"
  echo -n "$MSG"
}

print_err()
{
  MSG="$*"
  if [ -w /dev/stderr ] ; then
    echo "$MSG" >> /dev/stderr
  else
    echo "$MSG"
  fi
}

# GU: For Android Honeycomb, make sure we pull in "busybox"
export PATH=/system/xbin/busybox:/sbin:$PATH

# set the path to include "standard" locations so commands below can be found
#PATH="/sbin:/usr/sbin:/usr/local/sbin:/bin:/usr/bin/:/usr/local/sbin:/usr/local/bin:/usr/local/gnu/bin:"${PATH}""
#export PATH
# ------------------------------ COMMANDS ------------------------------------

CHGRP="chgrp"
CHMOD="chmod"
CUT="cut"
DIRNAME="dirname"
GREP="grep"
INSMOD="insmod"
MKNOD="mknod"
MKDIR="mkdir"
RM="rm"
SED="sed"
STAT="stat"
SU="su"
TR="tr"
UNAME="uname"

COMMANDS_TO_CHECK="${CHGRP} ${CUT} ${DIRNAME} ${GREP} ${INSMOD} ${MKNOD} ${MKDIR} ${RM} ${SED} ${STAT} ${SU} ${TR} ${UNAME}"

# if any of the COMMANDS_TO_CHECK are not executable, then exit script
OK="true"
for c in ${COMMANDS_TO_CHECK} ; do
  CMD=`type -P $c 2>&1` ;
  if [ -z "${CMD}" ] ; then
    OK="false"
    print_err "ERROR: unable to find command \"$c\" !"
  fi
done
if [ ${OK} != "true" ] ; then
  print_err "Please add the above commands to your PATH and re-run the script ... exiting."
  exit 255
fi

# ------------------------------ FUNCTIONS -----------------------------------

num_cpus=`${GREP} processor /proc/cpuinfo | ${SED} -e '1,$s/\t/ /g' | ${TR} -s ' ' | ${CUT} -d ' ' -f 3`

# function to show usage and exit
print_usage_and_exit()
{
  err=${1:-0}
  print_msg ""
  print_msg "Usage: $0 [ options ]"
  print_msg ""
  print_msg " where \"options\" are the following:"
  print_msg ""
  print_msg "    -g | --group group"
  print_msg "      restricts access to the ${DRIVER_NAME} driver to users in the specified"
  print_msg "      group; if this option is not provided, the group \"${DEFAULT_GROUP}\""
  print_msg "      will be used"
  print_msg ""
  print_msg "    -p | --perms fileperms"
  print_msg "      restricts access to the ${DRIVER_NAME} driver based on the specified"
  print_msg "      file permissions; if this option is not provided, then file"
  print_msg "      permissions \"${DEFAULT_PERMS}\" (or equivalently, \"ug+rw\") will be used"
  print_msg ""
  print_msg "    -q | --query"
  print_msg "      returns 0 if driver is already loaded, non-zero otherwise;"
  print_msg "      if driver is loaded, information on group ownership"
  print_msg "      and file permissions on driver device will be displayed"
  print_msg ""
  print_msg "    -r | --reload"
  print_msg "      attempt to reload all relevant drivers; note that drivers will"
  print_msg "      not unload if they are still in use"
  print_msg ""
  exit $err
}

# set the directory of the insmod-apwr2 script
SCRIPT_DIR=`dirname $0`

# Did the user specify a "DRIVER GROUP"?
was_group_specified=0

# check for certain options
reload_driver=0
while [ $# -gt 0 ] ; do
  case "$1" in
    -h | --help)
      print_usage_and_exit 0
      ;;
    -g | --group)
      DRIVER_GROUP=$2
      if [ -z "$DRIVER_GROUP" ] ; then
        print_err ""
        print_err "ERROR: must provide a group"
        print_usage_and_exit 254
      fi
	  was_group_specified=1
      shift
      ;;
    -p | --perms)
      DRIVER_PERMS=$2
      if [ -z "$DRIVER_PERMS" ] ; then
        print_err ""
        print_err "ERROR: must provide the file permissions"
        print_usage_and_exit 254
      fi
      shift
      ;;
    -q | --query)
      err_pwr=0
      driver_loaded=`lsmod | grep ${DRIVER_NAME}`
      if [ -z "$driver_loaded" ] ; then
        err_pwr=213
        print_msg "${DRIVER_NAME} driver is not loaded."
	  fi # SEP has subdev perms/groups checks here -- we have just the one device so no need to check
      exit $err_pwr
      ;;
    -r | --reload)
      reload_driver=1
      ;;
    *)
      print_err ""
      print_err "ERROR: unrecognized option \"$1\""
      print_usage_and_exit 254
      ;;
  esac
  shift
done

# ------------------------------ VARIABLES -----------------------------------

SCRIPT=$0
PLATFORM=`${UNAME} -m`
KERNEL_VERSION=`${UNAME} -r`
PLATFORM=`${UNAME} -m`
DRIVER_DIRECTORY=`${DIRNAME} ${SCRIPT}`
# use existing driver group and device permissions as default if available
if [ -e /dev/${DEV_FILE_NAME} ] ; then
  drv_group=`${STAT} --format "%G" /dev/${DEV_FILE_NAME}`
  drv_perms=`${STAT} --format "%a" /dev/${DEV_FILE_NAME}`
  echo "FOUND file: group = $drv_group, PERMS = $drv_perms"
else
  drv_group=${DEFAULT_GROUP}
  drv_perms=${DEFAULT_PERMS}
fi
DRIVER_GROUP=${DRIVER_GROUP:-${drv_group}}
DRIVER_PERMS=${DRIVER_PERMS:-${drv_perms}}

# check if platform is supported
if [ "${PLATFORM}" = "ia64" ] ; then
  ARCH="x64"
elif [ "${PLATFORM}" = "x86_64" ] ; then
  ARCH="x32_64"
elif [ "${PLATFORM}" = "i386" -o "${PLATFORM}" = "i486" -o "${PLATFORM}" = "i586" -o "${PLATFORM}" = "i686" ] ; then
  ARCH="x32"
else
  print_err ""
  print_err "ERROR: Unsupported platform \"${PLATFORM}\" ... exiting."
  print_err ""
  exit 253
fi

# ------------------------------- MAIN ---------------------------------------

# check if driver devices exist, and if so, then exit
DEVNUM=`${GREP} ${DEV_FILE_NAME} /proc/devices | ${TR} -s ' ' | ${CUT} -d ' ' -f 1`
if [ -n "${DEVNUM}" ] ; then
  if [ $reload_driver -ne 1 ] ; then
    print_err ""
    print_err "The ${DRIVER_NAME} driver is already loaded!  Use ${DRIVER_DIRECTORY}/${RMMOD_SCRIPT} to remove it."
    print_err ""
    exit 236
  fi
fi

# check if USER is root
if [ "${USER}x" != "rootx" ] ; then
  if [ ! -w /dev ] ; then
    print_msg "NOTE:  super-user or \"root\" privileges are required in order to continue."
    print_nnl "Please enter \"root\" "
    OPTIONS="-g ${DRIVER_GROUP} -p ${DRIVER_PERMS}"
    if [ $reload_driver -eq 1 ] ; then
      OPTIONS="$OPTIONS -r"
    fi
    exec ${SU} -c "/bin/bash ${SCRIPT} ${OPTIONS}"
    print_msg ""
    exit 0
  fi
fi

# check whether to reload the driver
if [ $reload_driver -eq 1 ] ; then
  (cd ${SCRIPT_DIR} && ./${RMMOD_SCRIPT} -s)
  err=$?
  if [ $err -ne 0 ] ; then
    print_err ""
    print_err "Error: failed to reload ${DRIVER_NAME} driver"
    print_err ""
    exit $err
  fi
fi

# check whether kernel is for UP or SMP
SMP=`${UNAME} -v | ${GREP} SMP`
if [ -z "${SMP}" ] ; then
  ARITY="up"
else
  ARITY="smp"
fi

# file name of the driver to load
#DRIVER_FILENAME=${DRIVER_NAME}-${ARCH}-${KERNEL_VERSION}${ARITY}.ko
DRIVER_FILENAME=${DRIVER_NAME}.ko

if [ ! -r ${DRIVER_DIRECTORY}/${DRIVER_FILENAME} ] ; then
  print_err ""
  print_err "Warning: ${DRIVER_NAME} driver \"${DRIVER_FILENAME}\""
  print_err "was not found in directory \"${DRIVER_DIRECTORY}\" !"
  print_err ""
  print_err "This means you may need to build ${DRIVER_NAME} driver from the provided"
  print_err "driver sources.  Please see the driver README for instructions."
  print_err ""
  exit 235
fi

# try to load the PAX driver if it was not already loaded
# GU: NOT supported for APWR

# check if PAX driver has same access rights as this driver
# GU: NOT supported for APWR

# insmod command to execute
INSMOD_CMD="${INSMOD} ${DRIVER_DIRECTORY}/${DRIVER_FILENAME}"

# execute the command
print_msg "Executing: ${INSMOD_CMD}"
${INSMOD_CMD}
INSMOD_RESULT=$?

# abort if unable to load the driver
if [ ${INSMOD_RESULT} -ne 0 ] ; then
  print_err ""
  print_err "Error:  ${DRIVER_NAME} driver failed to load!"
  print_err ""
  print_err "You may need to build ${DRIVER_NAME} driver for your kernel."
  print_err "Please see the ${DRIVER_NAME} driver README for instructions."
  print_err ""
  exit 234
fi

# check if the driver has been loaded into the kernel
DEVNUM=`${GREP} ${DEV_FILE_NAME} /proc/devices | ${TR} -s ' ' | ${CUT} -d ' ' -f 1`
if [ -z "${DEVNUM}" ] ; then
  print_err ""
  print_err "Error:  unable to find device \"${DRIVER_NAME}\" in /proc/devices !"
  print_err ""
  exit 233
fi

# remove any zombie APWR device files
if [ -e /dev/${DEV_FILE_NAME} ] ; then
  print_nnl "Deleting previously created /dev/${DEV_FILE_NAME} base devices ... "
  sleep 1
  ${RM} /dev/${DEV_FILE_NAME}
  print_msg "done."
fi

# create the APWR device file
print_nnl "Creating /dev/${DEV_FILE_NAME} character device file with major number ${DEVNUM} ... "
sleep 1
${MKNOD} /dev/${DEV_FILE_NAME} c ${DEVNUM} 0
MKNOD_RESULT=$?
if [ ${MKNOD_RESULT} -ne 0 ] ; then
  print_err ""
  print_err "Error:  unable to create required /dev/${DEV_FILE_NAME} character device file !"
  print_err ""
  exit 232
fi
print_msg "done."

# check if the driver readers were created
# GU: NOT supported for APWR

# create the percpu devices
# GU: NOT supported for APWR

# change group ownership to whichever group is permitted to open the driver
# UPDATE: do this ONLY if the user specifically requests it!!!
if [ $was_group_specified -eq 1 ]; then
	if [ -z "${DRIVER_GROUP}" ] ; then
		print_err ""
		print_err "Error:  no group ownership specified for /dev/${DEV_FILE_NAME} device ... exiting."
		print_err ""
		exit 231
	fi
	print_nnl "Setting group ownership of device to group \"${DRIVER_GROUP}\" ... "
	${CHGRP} ${DRIVER_GROUP} /dev/${DEV_FILE_NAME}
	CHGRP_RESULT=$?
	if [ ${CHGRP_RESULT} -ne 0 ] ; then
		print_err ""
		print_err "Error:  unable to change group ownership of device!"
		print_err ""
		exit 230
		fi
	print_msg "done."
fi

# show which driver was loaded
print_msg "The ${DRIVER_NAME} driver has been successfully loaded."

exit 0
